<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Magic tricks with fold functions | Leonardo Lazzaro</title><meta name=keywords content><meta name=description content="The first time you deal with foldr seems to be nothing more than a new function like map, filter.
However, when you get the concept of a recursion scheme, foldr becames a magical function. Commonly recursion calls are like this one:
sum:: Num a => [a] -> a sum [] = 0 sum (x:xs) = x + (sum xs) Very easy and intuitive to read, but what if we try to compute prod?"><meta name=author content><link rel=canonical href=https://www.lazzaro.com.ar/post/2014-04-18-magic-tricks-with-fold-functions/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.lazzaro.com.ar/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.lazzaro.com.ar/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.lazzaro.com.ar/favicon-32x32.png><link rel=apple-touch-icon href=https://www.lazzaro.com.ar/apple-touch-icon.png><link rel=mask-icon href=https://www.lazzaro.com.ar/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Magic tricks with fold functions"><meta property="og:description" content="The first time you deal with foldr seems to be nothing more than a new function like map, filter.
However, when you get the concept of a recursion scheme, foldr becames a magical function. Commonly recursion calls are like this one:
sum:: Num a => [a] -> a sum [] = 0 sum (x:xs) = x + (sum xs) Very easy and intuitive to read, but what if we try to compute prod?"><meta property="og:type" content="article"><meta property="og:url" content="https://www.lazzaro.com.ar/post/2014-04-18-magic-tricks-with-fold-functions/"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-04-18T00:00:00+00:00"><meta property="article:modified_time" content="2014-04-18T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Magic tricks with fold functions"><meta name=twitter:description content="The first time you deal with foldr seems to be nothing more than a new function like map, filter.
However, when you get the concept of a recursion scheme, foldr becames a magical function. Commonly recursion calls are like this one:
sum:: Num a => [a] -> a sum [] = 0 sum (x:xs) = x + (sum xs) Very easy and intuitive to read, but what if we try to compute prod?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.lazzaro.com.ar/post/"},{"@type":"ListItem","position":3,"name":"Magic tricks with fold functions","item":"https://www.lazzaro.com.ar/post/2014-04-18-magic-tricks-with-fold-functions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Magic tricks with fold functions","name":"Magic tricks with fold functions","description":"The first time you deal with foldr seems to be nothing more than a new function like map, filter.\nHowever, when you get the concept of a recursion scheme, foldr becames a magical function. Commonly recursion calls are like this one:\nsum:: Num a =\u0026gt; [a] -\u0026gt; a sum [] = 0 sum (x:xs) = x + (sum xs) Very easy and intuitive to read, but what if we try to compute prod?","keywords":[],"articleBody":"The first time you deal with foldr seems to be nothing more than a new function like map, filter.\nHowever, when you get the concept of a recursion scheme, foldr becames a magical function. Commonly recursion calls are like this one:\nsum:: Num a =\u003e [a] -\u003e a sum [] = 0 sum (x:xs) = x + (sum xs) Very easy and intuitive to read, but what if we try to compute prod?\nprod:: Num a =\u003e [a] -\u003e a prod [] = 1 prod (x:xs) = x * (sum xs) Nice! but we feel that this idea we wrote the same except for the base case and the function we want to use. Actually, in sum, we hardcoded “+” and in prod we hardcoded “*”, the same with the base case.\nThis is where the recursion scheme comes in to save our life and using foldr we can avoid “hardcoding” the function and base case. Let’s see some magic, simply magic to compute “sum”:\nsum = foldr (+) 0 yes! this new function “sum” does the same as the first one. The first time I saw this my brain was throwing exceptions…WTF is going on here? Well actually is pretty simple, but we need to look at the definition of foldr:\nfoldr:: (a-\u003eb-\u003eb) -\u003e b -\u003e [a] -\u003e b foldr combine base [] = base foldr combine base (x:xs) = combine x (foldr combine base xs) if we pass the list [1..13] to the latest version of sum, we can think that foldr will do this\n(1+(2+(3+(4+(5+(6+(7+(8+(9+(10+(11+(12+(13+0))))))))))))) so we can think of foldr as a way to associate parenthesis in our “expressions”. So, foldl instead will associate this way:\n(((((((((((((0+1)+2)+3)+4)+5)+6)+7)+8)+9)+10)+11)+12)+13) In sum, there is no difference in the result for obvious reasons.\nAnother interesting problem to study is to try dropWhile with foldr. I read the solution of dropWhile (on the Monad.Reader issue 6) after trying many ideas. Let’s look at my first idea:\nlet dropWhile’ predicate = foldr (\\x rec -\u003e if predicate x then rec else x:rec) [] Let’s try this with dropWhile':\ndropWhile' (\u003c3) [1,1,1,1,3,4,5,6] Which returns [3,4,5,6] and I was pretty happy with this function until I tried:\ndropWhile' (odd) [1,1,1,1,3,4,5,6] Which returns [4,6] and it makes obvious where the error is. Well, the first working solution (and human understandable) that Monad. Reader suggests is to use high order.\nlet dropWhile’’ predicate list= (foldr (\\x rec -\u003e if precidate x then rec.tail else id) id list) list Yes! Magic again and a pretty cool idea of using the tail as a “filter” and id for leaving what we want.\nBut a different approach and that will be using primitive recursion…\nrecr:: b-\u003e(a-\u003e[a]-\u003eb-\u003eb) -\u003e [a] -\u003e b recr base combine [] = base recr base combine (x:xs) = f x xs (recr base combine xs) And now let’s define dropWhile with recr:\ndropWhile''' = recr [] (\\x xs rec -\u003e if length xs == 0 then [x] else rec) recr is not in the Prelude, not sure why. With recr is pretty is to write the function insert, which is pretty hard to write with fold!\ninsert x = recr [x] (\\y ys zs -\u003e if x \u003c y then (x:y:ys) else (y:zs)) ","wordCount":"537","inLanguage":"en","datePublished":"2014-04-18T00:00:00Z","dateModified":"2014-04-18T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.lazzaro.com.ar/post/2014-04-18-magic-tricks-with-fold-functions/"},"publisher":{"@type":"Organization","name":"Leonardo Lazzaro","logo":{"@type":"ImageObject","url":"https://www.lazzaro.com.ar/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.lazzaro.com.ar accesskey=h title="Leonardo Lazzaro (Alt + H)">Leonardo Lazzaro</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.lazzaro.com.ar/ title=Home><span>Home</span></a></li><li><a href=https://www.lazzaro.com.ar/post/ title=Archives><span>Archives</span></a></li><li><a href=https://www.lazzaro.com.ar/about/ title=About><span>About</span></a></li><li><a href=https://www.lazzaro.com.ar/photography/ title=Photography><span>Photography</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Magic tricks with fold functions</h1><div class=post-meta><span title='2014-04-18 00:00:00 +0000 UTC'>2014-04-18</span></div></header><div class=post-content><p>The first time you deal with foldr seems to be nothing more than a new function like map, filter.</p><p>However, when you get the concept of a recursion scheme, foldr becames a magical function.
Commonly recursion calls are like this one:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>sum</span><span class=ow>::</span> <span class=kt>Num</span> <span class=n>a</span> <span class=ow>=&gt;</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=n>a</span>
</span></span><span class=line><span class=cl><span class=nf>sum</span> <span class=kt>[]</span> <span class=ow>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=nf>sum</span> <span class=p>(</span><span class=n>x</span><span class=kt>:</span><span class=n>xs</span><span class=p>)</span> <span class=ow>=</span> <span class=n>x</span> <span class=o>+</span> <span class=p>(</span><span class=n>sum</span> <span class=n>xs</span><span class=p>)</span></span></span></code></pre></div><p>Very easy and intuitive to read, but what if we try to compute prod?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>prod</span><span class=ow>::</span> <span class=kt>Num</span> <span class=n>a</span> <span class=ow>=&gt;</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=n>a</span>
</span></span><span class=line><span class=cl><span class=nf>prod</span> <span class=kt>[]</span> <span class=ow>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nf>prod</span> <span class=p>(</span><span class=n>x</span><span class=kt>:</span><span class=n>xs</span><span class=p>)</span> <span class=ow>=</span> <span class=n>x</span> <span class=o>*</span> <span class=p>(</span><span class=n>sum</span> <span class=n>xs</span><span class=p>)</span></span></span></code></pre></div><p>Nice! but we feel that this idea we wrote the same except for the base case and the function we want to use. Actually, in sum, we hardcoded &ldquo;+&rdquo; and in prod we hardcoded &ldquo;*&rdquo;, the same with the base case.</p><p>This is where the recursion scheme comes in to save our life and using foldr we can avoid &ldquo;hardcoding&rdquo; the function and base case. Let&rsquo;s see some magic, simply magic to compute &ldquo;sum&rdquo;:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>sum</span> <span class=ow>=</span> <span class=n>foldr</span> <span class=p>(</span><span class=o>+</span><span class=p>)</span> <span class=mi>0</span></span></span></code></pre></div><p>yes! this new function &ldquo;sum&rdquo; does the same as the first one. The first time I saw this my brain was throwing exceptions&mldr;WTF is going on here? Well actually is pretty simple, but we need to look at the definition of foldr:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>foldr</span><span class=ow>::</span> <span class=p>(</span><span class=n>a</span><span class=ow>-&gt;</span><span class=n>b</span><span class=ow>-&gt;</span><span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>b</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=n>b</span>
</span></span><span class=line><span class=cl><span class=nf>foldr</span> <span class=n>combine</span> <span class=n>base</span> <span class=kt>[]</span> <span class=ow>=</span> <span class=n>base</span>
</span></span><span class=line><span class=cl><span class=nf>foldr</span> <span class=n>combine</span> <span class=n>base</span> <span class=p>(</span><span class=n>x</span><span class=kt>:</span><span class=n>xs</span><span class=p>)</span> <span class=ow>=</span> <span class=n>combine</span> <span class=n>x</span> <span class=p>(</span><span class=n>foldr</span> <span class=n>combine</span> <span class=n>base</span> <span class=n>xs</span><span class=p>)</span></span></span></code></pre></div><p>if we pass the list [1..13] to the latest version of sum, we can think that foldr will do this</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl>  <span class=p>(</span><span class=mi>1</span><span class=o>+</span><span class=p>(</span><span class=mi>2</span><span class=o>+</span><span class=p>(</span><span class=mi>3</span><span class=o>+</span><span class=p>(</span><span class=mi>4</span><span class=o>+</span><span class=p>(</span><span class=mi>5</span><span class=o>+</span><span class=p>(</span><span class=mi>6</span><span class=o>+</span><span class=p>(</span><span class=mi>7</span><span class=o>+</span><span class=p>(</span><span class=mi>8</span><span class=o>+</span><span class=p>(</span><span class=mi>9</span><span class=o>+</span><span class=p>(</span><span class=mi>10</span><span class=o>+</span><span class=p>(</span><span class=mi>11</span><span class=o>+</span><span class=p>(</span><span class=mi>12</span><span class=o>+</span><span class=p>(</span><span class=mi>13</span><span class=o>+</span><span class=mi>0</span><span class=p>)))))))))))))</span></span></span></code></pre></div><p>so we can think of foldr as a way to associate parenthesis in our &ldquo;expressions&rdquo;. So, foldl instead will associate this way:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl>  <span class=p>(((((((((((((</span><span class=mi>0</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>+</span><span class=mi>2</span><span class=p>)</span><span class=o>+</span><span class=mi>3</span><span class=p>)</span><span class=o>+</span><span class=mi>4</span><span class=p>)</span><span class=o>+</span><span class=mi>5</span><span class=p>)</span><span class=o>+</span><span class=mi>6</span><span class=p>)</span><span class=o>+</span><span class=mi>7</span><span class=p>)</span><span class=o>+</span><span class=mi>8</span><span class=p>)</span><span class=o>+</span><span class=mi>9</span><span class=p>)</span><span class=o>+</span><span class=mi>10</span><span class=p>)</span><span class=o>+</span><span class=mi>11</span><span class=p>)</span><span class=o>+</span><span class=mi>12</span><span class=p>)</span><span class=o>+</span><span class=mi>13</span><span class=p>)</span></span></span></code></pre></div><p>In sum, there is no difference in the result for obvious reasons.</p><p>Another interesting problem to study is to try dropWhile with foldr. I read the solution of dropWhile (on the Monad.Reader issue 6) after trying many ideas. Let&rsquo;s look at my first idea:</p><p>let dropWhile&rsquo; predicate = foldr (\x rec -> if predicate x then rec else x:rec) []
Let&rsquo;s try this with dropWhile':</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>dropWhile&#39;</span> <span class=p>(</span><span class=o>&lt;</span><span class=mi>3</span><span class=p>)</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>6</span><span class=p>]</span></span></span></code></pre></div><p>Which returns [3,4,5,6] and I was pretty happy with this function until I tried:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>dropWhile&#39;</span> <span class=p>(</span><span class=n>odd</span><span class=p>)</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>6</span><span class=p>]</span></span></span></code></pre></div><p>Which returns [4,6] and it makes obvious where the error is. Well, the first working solution (and human understandable) that Monad. Reader suggests is to use high order.</p><p>let dropWhile&rsquo;&rsquo; predicate list= (foldr (\x rec -> if precidate x then rec.tail else id) id list) list
Yes! Magic again and a pretty cool idea of using the tail as a &ldquo;filter&rdquo; and id for leaving what we want.</p><p>But a different approach and that will be using primitive recursion&mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>recr</span><span class=ow>::</span> <span class=n>b</span><span class=ow>-&gt;</span><span class=p>(</span><span class=n>a</span><span class=ow>-&gt;</span><span class=p>[</span><span class=n>a</span><span class=p>]</span><span class=ow>-&gt;</span><span class=n>b</span><span class=ow>-&gt;</span><span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=n>b</span>
</span></span><span class=line><span class=cl><span class=nf>recr</span> <span class=n>base</span> <span class=n>combine</span> <span class=kt>[]</span> <span class=ow>=</span> <span class=n>base</span>
</span></span><span class=line><span class=cl><span class=nf>recr</span> <span class=n>base</span> <span class=n>combine</span> <span class=p>(</span><span class=n>x</span><span class=kt>:</span><span class=n>xs</span><span class=p>)</span> <span class=ow>=</span> <span class=n>f</span> <span class=n>x</span> <span class=n>xs</span> <span class=p>(</span><span class=n>recr</span> <span class=n>base</span> <span class=n>combine</span> <span class=n>xs</span><span class=p>)</span></span></span></code></pre></div><p>And now let&rsquo;s define dropWhile with recr:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>dropWhile&#39;&#39;&#39;</span> <span class=ow>=</span> <span class=n>recr</span> <span class=kt>[]</span> <span class=p>(</span><span class=nf>\</span><span class=n>x</span> <span class=n>xs</span> <span class=n>rec</span> <span class=ow>-&gt;</span> <span class=kr>if</span> <span class=n>length</span> <span class=n>xs</span> <span class=o>==</span> <span class=mi>0</span> <span class=kr>then</span> <span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=kr>else</span> <span class=n>rec</span><span class=p>)</span></span></span></code></pre></div><p>recr is not in the Prelude, not sure why. With recr is pretty is to write the function insert, which is pretty hard to write with fold!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>insert</span> <span class=n>x</span> <span class=ow>=</span> <span class=n>recr</span> <span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=p>(</span><span class=nf>\</span><span class=n>y</span> <span class=n>ys</span> <span class=n>zs</span> <span class=ow>-&gt;</span> <span class=kr>if</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>y</span> <span class=kr>then</span> <span class=p>(</span><span class=n>x</span><span class=kt>:</span><span class=n>y</span><span class=kt>:</span><span class=n>ys</span><span class=p>)</span> <span class=kr>else</span> <span class=p>(</span><span class=n>y</span><span class=kt>:</span><span class=n>zs</span><span class=p>))</span></span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>